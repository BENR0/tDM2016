
<!-- Ein-Variable-Analysis von Radiation -->



```{r load_packages_Benja, echo=FALSE, error=FALSE, message=FALSE, include=FALSE,eval=eval_block}
#load packages
packages <- c("tidyr", "dplyr", "DataIO", "lubridate", "zoo", "xts", "stringr", "timeSeries", "tseries", "car",
              "AdaptGauss", "forecast", "kfigr", "dbt.RetroMAT", "RHmm", "FinTS", "knitr", "depmixS4")
lapply(packages,library,character.only=TRUE)
#set prefix for figure numbering
opts_knit$set(kfigr.prefix = TRUE)
#figure captions in html with chunk options
# knit_hooks$set(htmlcap = function(before, options, envir) {
#   if(!before) {
#     paste('<p class="caption">',options$htmlcap,"</p>",sep="")
#     }
#     })

```


## Chirimachay_Netradiation
```{r inspect_data_length, echo = FALSE}
summaryRad <- summarizeData(zooRad)
summaryNO3 <- summarizeData(zooNO3)   #can't be used in Analysis for No3 because data are being trimed
summaryPrecip <- summarizeData(zooPrecip, zero.as.nan = FALSE)    #can't be used in Analysis for Precip because data are being trimed
```

Der Datensatz besteht aus einer Zeitreihe mit `r summaryRad$NumDatPoints` Werten
und beginnt `r summaryRad$Start` und endet `r summaryRad$End`. Gemessen wurde
die Netto Strahlung in Watt je Quadratmeter mit einem Messintervall von `r summaryRad$Delta`
Minuten. Die Datenpunkte haben alle den `r summaryRad$Regulär` und es fehlen
`r summaryRad$NumMissing` Datenpunkte. Das Minimum respektive das Maximum des
Datensatzes liegen bei `r summaryRad$Min` sowie `r summaryRad$Max`.

```{r inspect_data_2, echo = FALSE, fig.cap = figNum("Visuelle Inspektion des Datensatzes")}
#check stationaritry with dickey fuller (package: tseries)
adf.test(zooRad, k = 0)

plot(zooRad, xlab = "Zeit", ylab = "Netto Strahlung")
```

```{r difference_plot, echo = FALSE, fig.cap = figNum("Differenz des Datensatzes")}
#calculate difference
zooraddiff <- diff(zooRad)
plot(zooraddiff, xlab = "Zeit", ylab = "Differenze netto Strahlung")
```

Da Strahlung gemessen wird ist zu erwarten das es starken dijurnale Schwankungen
im Datensatz gibt. Darüber hinaus handelt es sich um eine Flächenhafte Messgröße
weshalb sich aller Wahrscheinlichkeit nach eine Wurzeltransformation der Daten
vorteilhaft erweisen könnte.

```{r sqrt, echo = FALSE,fig.cap = figNum("Mit Wulzel transformierte Daten")}
sqrtzooRad <- sqrt(zooRad)
overviewPlot(coredata(sqrtzooRad))
```

Es zeigt sich das die Verteilung der Daten trotz Wurzeltransformation nicht
Normalverteilt ist und einige Extreme Werte enthalten. Weitere Analyse zeigt
das die 6. Wurzel der Daten zumindest die extremen Werte einfängt. Weiterhin
zeigt sich das die Daten bimodal verteilt sind.

```{r sixth_root, echo = FALSE,fig.cap = figNum("Mit 6-te Wulzel transformierte Daten")}
sixthroot <- zooRad^(1/6)
overviewPlot(coredata(sixthroot))
```

***
###GMM
```{r GMM_Benj, echo = FALSE, fig.cap = figNum("GMM für mit 6-te Wulzel transformierte Daten, 2 Gauss")}
#GMMRad <- AdaptGauss(coredata(sixthroot))
GMMRadMeans <- c(1.34643, 2.14992)
GMMRadSDs <- c(0.205605, 0.404244)
GMMRadWeights <- c(0.486, 0.507)
GMMRadParRadius <- 0.0989202
GMMRadRMS <- 0.1106062
GMMRadBayBound <- 1.679349

PlotMixturesAndBoundaries(coredata(sixthroot), GMMRadMeans, GMMRadSDs, GMMRadWeights, SingleGausses = TRUE, lwd=3)
```

Der erste Eindruck des Gauß-Mixturen Modells suggeriert das die 6. Wurzel aus dem
Datensatz gut mittels zweier Gauß Funktionen modelliert werden kann. Der QQ-Plot
sowie ein nachfolgend ausgeführter Chi-Quadrat Test zeigen das die Daten nicht der
Verteilung des Modells entsprechen. Insbesondere an den Enden der Modellverteilung
sowie in der Mitte weichen die Daten deutlich ab.

```{r QQ_GMM_Benj, echo = FALSE,fig.cap = figNum("GMM Verifizierung, QQplot gegen Normalverteilung")}
QQplotGMM(coredata(sixthroot), GMMRadMeans, GMMRadSDs, GMMRadWeights)

#sixthrootKS <- KStestMixtures(coredata(sixthroot), GMMRadMeans, GMMRadSDs, GMMRadWeights)
#sixthrootChis <- Chi2testMixtures(coredata(sixthroot), GMMRadMeans, GMMRadSDs, GMMRadWeights)
```

```{r Chi_test_GMM_Benj, echo = FALSE,fig.cap = figNum("GMM Verifizierung, Chi-Quadrat-Test")}
#sixthrootKS <- KStestMixtures(coredata(sixthroot), GMMRadMeans, GMMRadSDs, GMMRadWeights)
sixthrootChis <- Chi2testMixtures(coredata(sixthroot), GMMRadMeans, GMMRadSDs, GMMRadWeights,PlotIt = T)
```

***
```{r FFT_Benj, echo = FALSE, eval = eval_block}
specsixthroot <- spectrum(sixthroot, spans = c(3,9))

#get sampling frequency of data
freq <- frequency(sixthroot)
Nyfreq <- freq/2
Nf <- length(coredata(sixthroot))/2


sixthrootFFT <- fft(coredata(sixthroot))/length(coredata(sixthroot))
plot(Mod(sixthrootFFT[2:4000]), type = "l", xlab = "Frequenz (Hz)")

sixthrootFFT2 <- ifft(coredata(sixthroot))/length(coredata(sixthroot)) #Pakete: pracma
plot(Mod(sixthrootFFT2[2:300]), type = "l", xlab = "Frequenz (Hz)")
```


### Analyse der multivariaten Zeitreihe

Um einen visuellen Eindruck für mögliche nachfolgende Analysemethoden zu erhalten
ist die 3 Dimensionale Zeitreihe zunächst mittels Umatrix verfahren projeziert worden.

```{r umatrix, echo = FALSE, eval = TRUE}
esommatrix <- esom(as.matrix(modelData))

umatrix <- calcUmatrix(esommatrix$EsomNeurons)
plotUmatrix(umatrix)
```

es zeigt sich das keine sehr ausgeprägten Cluster im Datensatz vorhanden sind.
Möglicherweise lässt sich jedoch mittels eines Hidden-Markow Model Ansatzes und
den Informationen aus der Umatrix Projektion ein Zusammenhang mit drei oder vier
Zuständen im Datensatz modellieren.
Daher ist unter der Annahme des einfachsten Modells zunächst einen Analyse
mit 3 Zuständen gerechnet worden.

```{r HMM_Multivariate_Benj, echo = FALSE, eval = TRUE}
modelData <- as.data.frame(coredata(tsAll))

HMM3 <- depmix(list(zooRad ~ 1, zooNO3 ~ 1, aggPrecip ~ 1), data = modelData, nstates = 3, family = list(gaussian(), gaussian(), gaussian()))

set.seed(1)
HMMfit3 <- fit(HMM3)
print(HMMfit3)
summary(HMMfit3)

HMM3post <- posterior((HMMfit3))
#merge to time series again for plottin
HMM3post$datetime <- index(tsAll)
tsHMM <- zoo(data.frame(states = HMM3post$state, datetime = HMM3post$datetime))
plot(tsHMM)

#HMM4 <- depmix(list(zooRad ~ 1, zooNO3 ~ 1, aggPrecip ~ 1), data = modelData, nstates = 4, family = list(gaussian(), gaussian(), gaussian()))

#set.seed(1)
#HMMfit4 <- fit(HMM4)
#print(HMMfit4)
#summary(HMMfit4)
```


