---
title: "Temporal Datamining WS 2"
author: "Benjamin Roesner, Marta Lemanczyk, Jiachun Zhang"
output:
  html_document:
    css: style.css
    fig_caption: true
    fig_height: 5
    fig_width: 7
    fig_retina: 1
    highlight: pygments
    number_sections: true
    theme: spacelab
    toc: yes
    toc_depth: 2
  pdf_document:
    toc: yes
---
------

```{r chunk options and functions, echo=FALSE, eval = TRUE}
#eval: evaluate code chunk true/false
#include: include chunk in ouput document true/false (code still evaluated and plots generated)
#echo: include source code true/
#error: true/false display error messages
#message: true/ false display messages
#warning: true/false display warning messages
#eval: true/false evaluate block -> use with variable eval_block
#cache: cache results -> use with variable cache_erg
#fig.cap = figNum("FIG CAPTION"): figure captions, with numbering by figNum function (see below)
#anchor = "figure": use with package kfigr to get inline reference to images with number by using function figr("NAME OF CHUNK WITH FIGURE")

#child = "file.Rmd": include file

#links
#[SECTION NAME][LINK NAME]

#citation from lit.bib
#[@LITSHORTNAME]

#figure number counter function
figNum = local({
  i = 0
  function(x) {
    i <-  i + 1
    paste("Figure ", i, ": ", x, sep = "")
  }
})


#flag to easily change evaluation of code blocks in results section
eval_block <- FALSE
#flag if reading and plotting should be cached
cache_erg <- FALSE
```

```{r problem specific functions, echo = FALSE, include = FALSE}
loadData <- function(flist, names = unlist(lapply(seq(1, length(flist)), function(x) paste0("d", x)))){
  for (f in files){
    assign(names[which(flist == f)], as.data.frame(ReadLRN(basename(f), dirname(f))$Data), envir = .GlobalEnv)
    }
}

summarizeData <- function(data){
  if(class(data) == "zoo"){
    #start and end points of ts
    st <- start(data)
    end <- end(data)
    #sample intervall of data in minutes
    delta <- deltat(data)/60
    #check if ts is evenly spaced
    reg <- ifelse(is.regular(data), "gleichen Abstand", "nicht den gleichen Abstand")
  } else {
    st <- NULL
    end <- NULL
    delta <- NULL
    reg <- NULL
    }
  len <- length(data)
  lenZeros <- length(which(data == 0 | is.nan(data) | is.null(data)))
  min <- min(data)
  max <- max(data)
  res <- list(Start = st, End = end, NumDataPoints = len, NumMissing = lenZeros, Min = min, Max = max, Regulär = reg, Delta = delta)
  return(res)
}

# Funktion, um die erste bzw.letzte 10 Ertraege zu sehen
# Funktion, um die erste bzw.letzte 10 Ertraege zu sehen
printData <- function(data){
  print("Erste bzw. letzte 10 Werte des Datensatzes")
  head(data, n = 10)
  tail(data, n = 10)
}

# Histogram,PDEplot,QQplot,Boxplot,NaN Anzahl
overviewPlot <- function(data, name = "data"){
  par(mfrow = c(2,3)) 
  #mat <- matrix(c(1,2,0,3,4,5),2,byrow = T)
  #layout(mat,c(5,5,1),c(1,1))
  
  MinD <- nanmin(data)
  MaxD <- nanmax(data)
  
  # Histogramm
  hist(data, ylab = "Nr of Data")
  
  # PDE-Dichte
  #PDEplot(data,title=name, xlab=name);  # Bei mir kann das Plot nicht verkleinert werden
  pdeVal <- ParetoDensityEstimation(data, ParetoRadius(data))
  plot(pdeVal$kernels, pdeVal$paretoDensity, type = "l", xlab = "Data", ylab = "PDE", main = name)
  #plot(density(data),main=name);
  
  plot.new()
  
  # QQplot
  qqnorm(data, ylab = name)
  gridOn() 
  
  # Boxplot
  boxplot(data, xlab=name, main = paste("Range:[ ", num2str(round(MinD, 5)), " ,", num2str(round(MaxD, 5)) ," ]"), axes = FALSE)
  
  
  # Barplot fuer die NaNs
  NaNs <- (sum(is.infinite(data)) + sum(is.na(data)))/length(data)
  barplot(NaNs, ylab = "NaNs in %", main = paste(round(NaNs, 4), " %"), xlim = c(0, 3), ylim = c(0, 1))
  if (any(is.nan(data), na.rm = TRUE)) 
    print("NaNs in Data found. This message is only important, if after rounding the percent of NaN is zero in the bar plot.")
  if (any(is.infinite(data), na.rm = TRUE)) 
    warning("Infinite values in Data found.")
  
  par(mfrow = c(1,1))
}
```

```{r load_packages, echo=FALSE, error=FALSE, message=FALSE, include=FALSE}
#load packages
packages <- c("tidyr", "dplyr", "DataIO", "lubridate", "zoo", "stringr", "timeSeries", "tseries", "car", "AdaptGauss", "forecast", "kfigr", "dbt.RetroMAT", "RHmm", "FinTS", "knitr")
lapply(packages,library,character.only=TRUE)
#set prefix for figure numbering
#opts_knit$set(kfigr.prefix = TRUE)
#figure captions in html with chunk options
knit_hooks$set(htmlcap = function(before, options, envir) {
  if(!before) {
    paste('<p class="caption">',options$htmlcap,"</p>",sep="")
    }
    })

```


```{r load_data, echo = FALSE}
files <- list.files("../data", pattern = "p2_", full.names = TRUE)

loadData(files, c("dataRad", "dataNO3", "dataPrecip"))

dataNO3$HH <- str_pad(dataNO3$HH, 2, c("left"), "0")
dataNO3$Min <- str_pad(dataNO3$Min, 2, c("left"), "0")

dataNO3 <- unite_(dataNO3, "time", c("HH", "Min"), sep = ":")
dataNO3 <- unite_(dataNO3, "date", c("YYYY", "MM", "DD"), sep = "-")
dataNO3 <- unite_(dataNO3, "datetime", c("date", "time" ), sep = " ")
#dataNO3 <- select(dataNO3, datetime, NNO3mgl)
dataNO3$datetime <- parse_date_time(dataNO3$datetime, order = "Ymd HM")


dataRad$HH <- str_pad(dataRad$HH, 2, c("left"), "0")
dataRad$Min <- str_pad(dataRad$Min, 2, c("left"), "0")

dataRad <- unite_(dataRad, "time", c("HH", "Min"), sep = ":")
dataRad <- unite_(dataRad, "date", c("YYYY", "MM", "DD"), sep = "-")
dataRad <- unite_(dataRad, "datetime", c("date", "time" ), sep = " ")
#dataRad <- select(dataRad, datetime, CorrectedNetRadiationWm2)
dataRad$datetime <- parse_date_time(dataRad$datetime, order = "Ymd HM")
zooRad <- read.zoo((data.frame(datetime = dataRad$datetime, rad = dataRad$CorrectedNetRadiationWm2)))


dataPrecip$HH <- str_pad(dataPrecip$HH, 2, c("left"), "0")
dataPrecip$Min <- str_pad(dataPrecip$Min, 2, c("left"), "0")

dataPrecip <- unite_(dataPrecip, "time", c("HH", "Min"), sep = ":")
dataPrecip <- unite_(dataPrecip, "date", c("YYYY", "MM", "DD"), sep = "-")
dataPrecip <- unite_(dataPrecip, "datetime", c("date", "time" ), sep = " ")
#dataPrecip <- select(dataPrecip, datetime, PrecipitationMM)
dataPrecip$datetime <- parse_date_time(dataPrecip$datetime, order = "Ymd HM")

```
# Überblick über die Variablen
```{r inspect_data_length, echo = FALSE}
summaryData <- summarizeData(zooRad)
```

Der Datensatz besteht aus einer Zeitreihe mit `r summaryData$NumDatPoints` Werten
und beginnt `r summaryData$Start` und endet `r summaryData$End`. Gemessen wurde
die Netto Strahlung in Watt je Quadratmeter mit einem Messintervall von `r summaryData$Delta`
Minuten. Die Datenpunkte haben alle den `r summaryData$Regulär` und es fehlen
`r summaryData$NumMissing` Datenpunkte. Das Minimum respektive das Maximum des
Datensatzes liegen bei `r summaryData$Min` sowie `r summaryData$Max`.

```{r inspect_data_2, echo = FALSE, htmlcap = figNum("Visuelle Inspektion des Datensatzes")}
#check stationaritry with dickey fuller (package: tseries)
adf.test(zooRad, k = 0)

plot(zooRad, xlab = "Zeit", ylab = "Netto Strahlung")
```

```{r test plot, echo = FALSE, htmlcap = figNum("Differenz des Datensatzes")}
#calculate difference
zooraddiff <- diff(zooRad)
plot(zooraddiff, xlab = "Zeit", ylab = "Differenze netto Strahlung")
```

Da Strahlung gemessen wird ist zu erwarten das es starken dijurnale Schwankungen
im Datensatz gibt. Darüber hinaus handelt es sich um eine Flächenhafte Messgröße
weshalb sich aller Wahrscheinlichkeit nach eine Wurzeltransformation der Daten
vorteilhaft erweisen könnte.
```{r inspect_data_plot, echo = FALSE, fig.cap = "Inspect data", anchor = "figure", eval = eval_block}

overviewPlot(sqrt(coredata(dataRad)$CorrectedNetRadiationWm2))
```


```{r inspect_data_hist, echo = FALSE, eval = eval_block}
hist(dataNO3$NNO3mgl)
hist(dataPrecip$PrecipitationMM)
hist(dataRad$CorrectedNetRadiationWm2)
#check if data ist normal distributed
qqPlot(data$NNO3mgl)
qqPlot(dataPrecip$PrecipitationMM)
qqPlot(dataRad$CorrectedNetRadiationWm2)
```


```{r child = "P2_child_script_Jiachun.Rmd", eval = eval_block}
```
