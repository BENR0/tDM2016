---
title: "Teporales Data Mining, SS 2016"
subtitle: "Projekt 2, Wissen aus Hydrologie"
author: "Benjamin Roesner, Marta Lemanczyk, Jiachun Zhang"
output:
  html_document:
    css: style.css
    fig_caption: yes
    fig_retina: 1
    fig_height: 5
    fig_width: 7
    highlight: pygments
    number_sections: yes
    theme: united
    keep_md: no
    toc: yes
    toc_depth: 3
  pdf_document:
    highlight: zenburn
    toc: yes
---

```{r chunk options and functions, echo=FALSE, eval = TRUE}
#eval: evaluate code chunk true/false
#include: include chunk in ouput document true/false (code still evaluated and plots generated)
#echo: include source code true/
#error: true/false display error messages
#message: true/ false display messages
#warning: true/false display warning messages
#eval: true/false evaluate block -> use with variable eval_block
#cache: cache results -> use with variable cache_erg
#fig.cap = figNum("FIG CAPTION"): figure captions, with numbering by figNum function (see below)
#anchor = "figure": use with package kfigr to get inline reference to images with number by using function figr("NAME OF CHUNK WITH FIGURE")

#child = "file.Rmd": include file

#links
#[SECTION NAME][LINK NAME]

#citation from lit.bib
#[@LITSHORTNAME]

#figure number counter function
figNum = local({
  i = 0
  function(x) {
    i <<-  i + 1
    paste("Figure ", i, ": ", x, sep = "")
  }
})


#flag to easily change evaluation of code blocks in results section
eval_block <- FALSE
#flag if reading and plotting should be cached
cache_erg <- FALSE
```

```{r problem specific functions, echo = FALSE, include = FALSE}
loadData <- function(flist, names = unlist(lapply(seq(1, length(flist)), function(x) paste0("d", x)))){
  for (f in files){
    assign(names[which(flist == f)], as.data.frame(ReadLRN(basename(f), dirname(f))$Data), envir = .GlobalEnv)
    }
}

summarizeData <- function(data, zero.as.nan = TRUE){
  if(class(data) == "zoo"){
    #start and end points of ts
    st <- start(data)
    end <- end(data)
    #sample intervall of data in minutes
    delta <- deltat(data)/60      #deltat returns the time interval between observations
    #check if ts is evenly spaced
    reg <- ifelse(is.regular(data), "gleichen Abstand", "nicht den gleichen Abstand")
  } else {
    st <- NULL
    end <- NULL
    delta <- NULL
    reg <- NULL
    }
  len <- length(data)
  if(zero.as.nan){
    lenZeros <- length(which(data == 0 | is.nan(data) | is.null(data)))
  } else {
    lenZeros <- length(which(is.nan(data) | is.null(data)))
  }
  
  min <- min(data)
  max <- max(data)
  res <- list(Start = st, End = end, NumDataPoints = len, NumMissing = lenZeros, Min = min, Max = max, Regulaer = reg, Delta = delta)
  return(res)
}


# Funktion, um die erste bzw.letzte 10 Ertraege zu sehen
printData <- function(data){
  print("Erste bzw. letzte 10 Werte des Datensatzes")
  #head(data, n = 10)
  #tail(data, n = 10)
  print(data[1:10,])
  temp=nrow(data)
  print(data[(temp-10):temp,])
}

# Histogram,PDEplot,QQplot,Boxplot,NaN Anzahl
overviewPlot <- function(data, name = "data"){
  par(mfrow = c(2,3)) 
  #mat <- matrix(c(1,2,0,3,4,5),2,byrow = T)
  #layout(mat,c(5,5,1),c(1,1))
  
  MinD <- nanmin(data)
  MaxD <- nanmax(data)
  
  # Histogramm
  hist(data, ylab = "Nr of Data")
  
  # PDE-Dichte
  #PDEplot(data,title=name, xlab=name);  # Bei mir kann das Plot nicht verkleinert werden
  pdeVal <- ParetoDensityEstimation(data, ParetoRadius(data))
  plot(pdeVal$kernels, pdeVal$paretoDensity, type = "l", xlab = "Data", ylab = "PDE", main = name)
  #plot(density(data),main=name);
  
  plot.new()
  
  # QQplot
  qqnorm(data, ylab = name)
  gridOn() 
  qqline(data, col="blue",lwd=3)
  
  # Boxplot
  boxplot(data, xlab=name, main = paste("Range:[ ", num2str(round(MinD, 5)), " ,", num2str(round(MaxD, 5)) ," ]"), axes = FALSE)
  
  
  # Barplot fuer die NaNs
  NaNs <- (sum(is.infinite(data)) + sum(is.na(data)))/length(data)
  barplot(NaNs, ylab = "NaNs in %", main = paste(round(NaNs, 4), " %"), xlim = c(0, 3), ylim = c(0, 1))
  if (any(is.nan(data), na.rm = TRUE)) 
    print("NaNs in Data found. This message is only important, if after rounding the percent of NaN is zero in the bar plot.")
  if (any(is.infinite(data), na.rm = TRUE)) 
    warning("Infinite values in Data found.")
  
  par(mfrow = c(1,1))
}

#modified adapt gauss function without active input through shiny app
getOptGauss <- function(Data, Kernels = ParetoDensityEstimation(Data, paretoRadius = ParetoRadius(Data))$kernels, ParetoDensity = ParetoDensityEstimation(Data, paretoRadius = ParetoRadius(Data))$paretoDensity, fast = TRUE){ 
    # Teste RMS fuer einen Gauss
    Mean1 <- mean(Data)
    Deviation1 <- sd(Data)
    Weight1 <- 1
    Var=EMGauss(Data,fast=fast)
    Mean1 <- Var$Means
    Deviation1 <- Var$SDs
    Weight1 <- Var$Weights
    Fi <- dnorm(Kernels,Mean1,Deviation1)*Weight1
    RMS1 <- sqrt(sum((Fi-ParetoDensity)^2))
    
    # Teste RMS fuer 2 Gauss
    Means2 <- c(0,0)
    Deviations2 <- c(0,0)
    Weights2 <- c(0,0)
    Valskmeans <- kmeans(Data,2,iter.max=100)
    KValues <- Valskmeans$cluster
    #print(KValues2)
    for (i in 1:2){
      Means2[i] <- mean(Data[KValues==i])
      Deviations2[i] <- sd(Data[KValues==i])
      Weights2[i] <- sum(KValues==i)
      if (is.na(Deviations2[i])) {Deviations2[i] <- 0}
    }
    Weights2 <- Weights2/length(KValues)
    Var=EMGauss(Data,Means2,Deviations2,Weights2,10,fast=fast)
    Means2 <- Var$Means
    Deviations2 <- Var$SDs
    Weights2 <- Var$Weights
    Fi <- 0
    for (i in 1:2){
      Fi <- Fi+dnorm(Kernels,Means2[i],Deviations2[i])*Weights2[i]
    }
    RMS2 <- sqrt(sum((Fi-ParetoDensity)^2))
    
    # Teste RMS fuer 3 Gauss
    Means3 <- c(0,0,0)
    Deviations3 <- c(0,0,0)
    Weights3 <- c(0,0,0)
    Valskmeans <- kmeans(Data,3,iter.max=100)
    KValues <- Valskmeans$cluster
    #print(KValues2)
    for (i in 1:3){
      Means3[i] <- mean(Data[KValues==i])
      Deviations3[i] <- sd(Data[KValues==i])
      Weights3[i] <- sum(KValues==i)
      if (is.na(Deviations3[i])) {Deviations3[i] <- 0}
    }
    Weights3 <- Weights3/length(KValues)
    Var=EMGauss(Data,Means3,Deviations3,Weights3,10,fast=fast)
    Means3 <- Var$Means
    Deviations3 <- Var$SDs
    Weights3 <- Var$Weights
    Fi <- 0
    for (i in 1:3){
      Fi <- Fi+dnorm(Kernels,Means3[i],Deviations3[i])*Weights3[i]
    }
    RMS3 <- sqrt(sum((Fi-ParetoDensity)^2))
    
    # ueberpruefe ob RMS1( 1 Gauss) oder RMS2 (3 Gauss ) kleiner ist. Speichere zugehoerige means, deviations und weights
    SSE <- c(RMS1^2*log(3), RMS2^2*log(3*2), RMS3^2*log(3*3))
    #SSE <- c(RMS1^2*log(3), RMS2^2*log(3*2))
    minSSEind <- which.min(SSE)
    switch(as.character(minSSEind),
           "1" = {means <- Mean1
                deviations <- Deviation1
                weights <- Weight1
                rms <- RMS1},
           "2" = {means <- Means2
                deviations <- Deviations2
                weights <- Weights2
                rms <- RMS2},
           "3" = {means <- Means3
                deviations <- Deviations3
                weights <- Weights3
                rms <- RMS3}
           )
    # Ordne gaussians nach mean
    order <- order(means)
    means <- means[order]
    deviations <- deviations[order]
    weights <- weights[order]
    rms <- rms
    out=list(means=means,deviations=deviations,weights=weights, rms = rms)
    
    
    return(out)
  }
```

```{r load_packages, echo=FALSE, error=FALSE, message=FALSE, include=FALSE}
#load packages
packages <- c('ABCanalysis','AdaptGauss','DataVisualisation','GabrielGraph','GabrielGraph','Umatrix','dbt.attributes','dbt.BDM','dbt.CART','ClassAnalysis','dbt.classifiers','dbt.ColorScale','dbt.ColorScale','DataIO','dbt.DelaunayVoronoi','Dist','dbt.Distances','dbt.DNAarrays','dbt.general','dbt.GraphAlgorithms','dbt.HESKES','dbt.IGCfiles','dbt.InteractiveTools','dbt.MixtureModel','dbt.nanHandling','dbt.NeuronalNets','pareto','dbt.Plot','dbt.Projections','dbt.RetroMAT','dbt.Statistics','reshape2','caTools','dbt.Transforms') #dbt Pakete
packages = c(packages,"kfigr", "knitr") #Pakete für knit
packages = c(packages,'FinTS','tseries') #Pakete für GARCH

packages <- c(packages, "tidyr", "dplyr", "lubridate", "zoo", "stringr", "timeSeries",  "car", "forecast", "dbt.RetroMAT", "RHmm",  "depmixS4",'pracma')  # from Benjamin

lapply(packages,library,character.only=TRUE)

#set prefix for figure numbering
opts_knit$set(kfigr.prefix = TRUE)

#figure captions in html with chunk options
# knit_hooks$set(htmlcap = function(before, options, envir) {
#   if(!before) {
#     paste('<p class="caption">',options$htmlcap,"</p>",sep="")
#     }
#     })

```


```{r Jiachun NO3 Precip data, child = "P2_NO3_Precip.Rmd"}
```

```{r Benjamin_Radiation_data, child = "P2_Rediation.Rmd"}
```


```{r Corvarianzanalysis, child = "P2_Corvarianzanalysis",eval=eval_block}
```